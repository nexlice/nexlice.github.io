---
title: Pruning
tags: 
 - Block File Pruning
 - State Trie Pruning

---

> 본 글은 Codestates BEB 코스의 자료에서 내용을 가져와 작성하였음을 알립니다.  

# Pruning
**프루닝(Pruning)**은 경량화 기법의 하나로, 
인공 지능(딥러닝) 분야에서 검색 모델을 학습한 후에 불필요하거나 중요도가 낮은 노드 등을 제거하는 기술을 일컫는다.  
<br>
이 ‘모델’은 매우 많은 수의 파라미터 값들로 구성된 그래프 형태로 구현했을 때,  
그래프의 에지를 제거하는 모습이 ‘가지치기’와 비슷한 형태를 띠어, 프루닝(가지치기)이라고 붙여졌다.  
<br>
나무의 가지치기 작업을 할 때, 중요한 부분은 꼭 남겨 놓고 잔가지를 다듬는 것과 같이,  
프루닝을 시도하여 불필요한 것을 제거한다고 하더라도 올바른 노드는 꼭 있어야 한다.  
<br>
이에 따라 성능의 저하를 최소화하고, 정확도를 높이는 일에 기여한다.  
프루닝은 블록체인에서 오래된 블록체인 데이터를 자동으로 삭제하기 위해 사용한다.  

---

## Bitcoin
비트코인의 노드는 블록체인의 사본을 보관하고 네트워크를 실행하는 데에 필요한 여러 태스크를 수행한다.  
그러나 하나의 문제가 있다면, 많은 스토리지를 낭비한다는 것이다.  
<br>
이 행위는 노드의 디스크 공간의 차지와 노드를 시작할 때 터무니없이 느린 인터넷 연결 속도를 만들어 냈고,  
그로 인해 많은 사람이 노드를 소유할 수 없게 만들었다.  
<br>
비트코인은 300GB 이상을 차지하는 블록체인이라는 DB가 있으며,  
비트코인의 모든 트랜잭션을 확인할 수 있고, 분 단위로 성장 중이다.  
다르게 말하자면 2009년 1월에 첫 번째 거래가 성사된 이후 10년이 넘는 동안,  
이 네트워크는 한 번도 작동을 중단하지 않았다.  
<br>
비트코인이 수년간 겪은 문제는 바로 ‘블록체인 크기의 가속화된 성장’이다.  
수십 메가바이트밖에 하지 않던 블록체인 레지스터리는 오늘날 수백 기가바이트로 늘어났다.  
또한 앞으로도 비트코인을 사용하는 사람들이 많아질수록 이 성장은 더욱 빠르고, 커질 것이다.  
<br>
이러한 이유로, bitcoin core 팀은 `Block file pruning`이라고 불리는 것을 `bitcoin core 0.11.0 version`에 추가했다.  
> 비트코인 블록체인의 ‘참조할 가능성이 없는 불필요한 정보’를 삭제한다면 비트코인의 용량은 10GB 미만의 수준으로 파악하고 있다.  
<br>
`Block File Pruning`을 통해 비트코인의 용량을 최적화할 수 있다 :
- Block pruning을 통해 작은 버전의 ‘풀 블록체인’을 실행할 수 있다.  
- 최신 블록체인을 다운로드하는 동안 필요하지 않은 오래된 데이터를 삭제할 수 있다.  
- prune mode에서 지갑을 실행하게 되면 이전 트랜잭션과 오래된 체인 기록이 삭제되어 디스크 공간을 절약할 수 있다.  

블록체인은 ‘머클 트리와 머클 루트’가 있는, 가장 오래된 것부터 최신 것까지 전부 연관된 거대한 나무와도 같다.  
모든 것을 살펴볼 수 있지만 크기가 크기 때문에 전부 저장하는 건 비효율적이다.  
<br>
비트코인이 블록을 실행하고 검증하는 데 중요한 것은, 블록 내 트랜잭션 내의 인/아웃풋의 사용 가능 여부이다.  
그렇기에 굳이 모든 트랜잭션을 저장하고 있지 않아도 된다.  
<br>
그러나 블록이 교체될 경우, 빠진 블록의 트랜잭션을 복구하는 과정이 필요하기 때문에 비교적 최신 정보만 가지고 있으면 된다.  
<br>
풀 블록체인을 다운로드하여, 다운로드가 올바른지 확인한 후에 필요한 ‘최신 정보’만 복사한 뒤 나머지는 버린다.  
저장한 블록체인은 풀 블록체인의 자식 트리(머클트리)이며, 원본 블록체인의 부분 복사본이다.  

---

## Ethereum
이더리움에서는 프루닝을 `State Trie Pruning`이라고 한다.  
<br>
State Trie Pruning은 현재 상태를 Prefix Tree의 일종인 Modified Merkle Patricia Trie(MPT, 상태전이 일반 머클 확장 페트리샤 트리)로 저장한다.  
이더리움에서 상태란, Account의 상태(Account state)이다.  
그리고, 이 상태들이 모여 Global State를 이루고, 이는 Key-Value의 데이터 구조로 저장하고 있다.  
> key : value = 32byte Address : Account state  

사용자가 늘어나게 되면 당연히 이더리움의 어카운트가 계속 늘어나고,  
수정 사항이 늘어나자 이는 계산이 버거워지고 느려지는 것으로 이어졌다.  
이를 위해 머클 트리를 도입하여 기존의 값을 변경하는 것은 어느 정도 해소하였지만,  
새로운 node를 추가하거나 삭제하는 것은 아직도 머클 트리의 정렬을 다시 계산해야 하는 복잡한 작업이다.  
<br>
이에, 이더리움에서는 몇 가지의 기능을 추가하며 머클트리를 보완했고,  
그 머클 트리가 바로 Modified Merkle Patricia Trie(MPT, 상태전이 일반 머클 확장 페트리샤 트리)이다.  
MPT는 State Root의 Hash를 계산하기 위해 전체를 볼 필요가 없다.  
수정된 브랜치의 Hash만 다시 계산하기에, 빠르게 root Hash를 찾을 수 있다.  

![state-trie-pruning](../../assets/img/state-trie-pruning.png)  

MPT는 새로 삽입되는 노드의 수를 최소화한다.  
예를 들어, 위의 그림에서 Block N과 Block N + 1의 차이는 A의 오른쪽 자식의 값이 10에서 20으로 변경된 것뿐이다.  
이 경우 10에서 20으로 변경된 노드의 부모 외의 다른 노드는 전부 기존의 노드를 재활용할 수 있다.  
따라서 푸른색으로 그려진 3개의 노드만 새로 추가하면 된다.  
<br>
그렇다면 더는 접근할 필요가 없는 노드들은 어떻게 될까?  
위의 예제에서 붉은색으로 표시된 3개의 노드는 Block N + 1에서는 필요 없는 노드이다.  
<br>
하지만 이 3개의 노드는 3개의 푸른색 노드가 추가되고 나면 바로 지울 수 없다.  
이더리움은 블록의 Finality를 보장하지 않는다.  
다른 말로 언제든지 Block N + 1이 Block N으로 Retract 될 수 있다.  
게다가 Web3 API를 통해서 과거의 State에 접근하는 것도 가능하기 때문에,  
현재 상태에서 안 쓰이는 노드를 바로 지울 수는 없다.  
<br>
그럼에도 노드들을 영원히 남겨둘 수도 없다.  
현재 이더리움에서 최신 State의 크기는 약 25GB 정도지만, 과거 State를 전부 저장하면 300GB를 넘어간다.  
게다가 이 크기는 점점 커질 것이기 때문에 이를 전부 저장하는 것은 현실적이지 못하다.  
이더리움은 접근할 수 있는 과거 State를 127개로 제한하여,  
그보다 오래된 State에만 포함된 노드는 지워도 되도록 했다.  
<br>
하지만 지워도 된다는 것과 지울 수 있다는 것은 별개의 문제이다.  
DB에 저장돼 있는 노드 중 최근 127개의 노드에서 접근할 수 없는 노드를 찾아 지우기는 쉬운 문제가 아니다.  

---

### Problems of Ethereum Pruning
이 문제는 컴퓨터 과학에서 오랫동안 풀어 온 Automatic Memory Management 문제와 비슷하다.  
실제로 비탈릭 부테린이 쓴 State Tree Pruning은 Reference Counting을 언급하고 있다.  
하지만 이더리움의 State Trie Pruning은 일반적인 Memory Management와 다른 점이 하나 있다.  
<br>
일반적인 Automatic Memory Management는 Volatile(휘발성이 있는)한 자원을 다룬다.  
따라서 프로그램이 비정상 종료되는 상황을 고려하지 않는다.  
프로그램이 종료되면 관리해야 할 자원이 남아 있지 않기 때문이다.  
<br>
하지만 State Trie의 노드는 DB에 저장되는 영속성 메모리이다.  
프로그램의 비정상 종료로 인해 State Trie가 비정상적인 상태가 되면 복구할 방법이 없다.  
비탈릭 부테린이 제시한 State Tree Pruning이 메인 넷에 들어가지 못한 것도 이런 이유이다.  
<br>
Reference Counting이 아닌 다른 방법으로 State Trie Pruning을 구현할 수도 있다.  
예를 들어 Trace를 이용하는 방법과 Tracing Garbage Collection도 Automatic Memory Management에서 흔히 사용되는 기법이다.  
하지만 Trace에 필요한 추가적인 메모리나, Stop-the-world에 의해 생기는 성능 문제 등이 먼저 해결돼야 한다.  
<br>
이러한 문제들로 현재 Go-Ethereum에서는 매우 한정적으로 State Trie Pruning을 한다.  
State Trie에 대해 캐시(Cache)를 사용하는데, 이 캐시에만 저장된 노드에 대해서는 Pruning을 하고 DB에 저장된 노드는 Pruning을 하지 않는 방식이다.  
캐싱된 노드는 서버가 정상적으로 종료되거나, 생성된 지 128 Block이 지났거나, 캐시 크기를 넘겼거나, 마지막으로 캐싱된 노드가 DB에 저장된 지 5분이 지나면 DB에 저장한다.  
즉, 위의 조건을 만족하기 전에 Cache에서 삭제된 노드는 DB에 저장하지 않는다.  
<br>
하지만 생성된 지 5분이 지나지 않아서 삭제되는 노드는 그리 많지 않다.  
따라서 대부분의 삭제됐어야 할 노드는 여전히 DB에 남아 있다.  
이에 대해 이더리움에서는 State Pruning을 구현하는 것을 계속 시도하고 있다.  
하지만, State Trie Pruning이 실제로 구현되기 전에는 Fast Sync를 사용하여 다음과 같은 방법을 사용하기를 권장한다.  
<br>
다음의 세 과정을 거치면, 새 노드에서는 Fast Sync로 동기화된 상태까지의 Garbage Node 없이 유효한 노드만 관리할 수 있다.

1. 새 클라이언트를 띄운다.  
2. 기존 클라이언트에서 새 클라이언트로 Fast Sync를 받는다.  
3. 기존 클라이언트를 지운다.  

언뜻 보기에는 주먹구구식 방식으로 보이지만,  
위험 부담이 있는 Garbage Collection을 구현하는 것보다 안전하고 현실적인 해결책이다.  
이더리움에 Garbage Collection이 구현되기 전까지는 계속 위와 같은 방식을 이용해야 할 것이다.